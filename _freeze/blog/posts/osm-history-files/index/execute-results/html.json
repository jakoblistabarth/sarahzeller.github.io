{
  "hash": "d3e691369e6eb2768b368f88c0a18a11",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthors:\n  - Jakob Listabarth\n  - Sarah Zeller\ntitle: \"Working with OSM history files in `R`\"\ndate: \"2025-07-03\"\ncategories: [code]\nimage: \"duck.png\"\ncitation: \n  url: https://sarahzeller.github.io/blog/posts/working-with-osm-history-files/\n\nformat:\n  html:\n    toc: true\n\nexecute:\n  warning: false\n  eval: false\n---\n\n\n\nWe're trying to find POIs throughout the history of OSM.\nLuckily, OSM does track when they are added.\nOnly drawback?\nWe're working with huuuuuuge files.\nLet's see how we can do that.\n\n::: {.callout-note}\nThis blogpost is based on a Windows workflow.\nOsmium is easier to set up on Linux.\n:::\n\nSo, what do we want to do?\nExtract\n\n-   POIs\n-   at different points of time\n-   in a specific bounding box\n\nfrom our OSM history file.\n\n# Downloading data from OSM\n\nWe're downloading the OSM history dump from [here](https://wiki.openstreetmap.org/wiki/Planet.osm/full).\nOSM's wiki also includes more information on this file.\n\n# Installing `osmium`\n\nThere's a software to work with these huge files: osmium.\nIt's a bit tricky to install on Windows, but this [blogpost](https://mathias-groebe.de/openstreetmap-daten-verarbeiten-impsom-und-osmium-unter-windows-nutzen/) details it really well.\nYou can download it [here](https://trac.osgeo.org/osgeo4w/).\n\nYou should note where you've installed osmium.\nFor me, it's `\"C:/OSGeo4W/bin/osmium.exe\"`.\n\n# Working with `osmium` through `R`\n\n::: {.callout-note}\n\nThere's also an `R` package called `rosmium`.\nWe're not working with it directly because it does not support features we need for history files.\n:::\n\n\n## Setting things up\n\nLet's load the necessary libraries in R first.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(duckdb)\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(purrr)\nlibrary(terra)\nlibrary(tidyterra)\n```\n:::\n\n\n\n\nThe file is huuuuge (around 140 GB), so we put it on an external drive.\nI'm guessing you'll do something similar.\nThis is why we're declaring the data folder separately.\n\nTo work with osmium in this specific workflow, we need to note where osmium lives on our computer.\nSo let's go ahead and define that as well.\n\nSo we'll have a set-up definition:\n\n-   where our data live (`data_root`)\n-   where our osmium lives (`osmium`)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata_root <- \"E:\"\n\nosmium <- \"C:/OSGeo4W/bin/osmium.exe\"\n```\n:::\n\n\n\nNext, let's define the area in which we are searching for POIs.\nIn our example, we're filtering for Togo.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbbox_togo <- c(\n  min_lon = -0.5,\n  min_lat = 5.5,\n  max_lon = 2,\n  max_lat = 11\n)\n```\n:::\n\n\n\n## Extracting the area\n\nOsmium allows to extract OSM data by a given bounding box with the function `extract`.\nOsmium is a command line tool, so we need a special function within `R` to invoke commands: `system2()`.\n\nThe following command \n\n-   extracts (line 4)\n-   from an OSM file (line 5) with history (line 6)\n-   within a bounding box (line 7)\n-   to an output file (line 8).\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\nsystem2(\n  osmium,\n  args = c(\n    \"extract\",\n    file.path(data_root, \"history-250623.osm.pbf\"),\n    \"--with-history\",\n    \"-b\", paste(bbox_togo, collapse = \",\"),\n    \"-o\", file.path(data_root, paste0(\"-history-250623\", paste(bbox_togo, collapse = \"_\"), \".osm.pbf\"))\n  )\n)\n```\n:::\n\n\n\n## Let's get temporal!\n\nWe're switching to the next `osmium` tool: `time-filter`.\nThis allows us to interact with the history part of the OSM history file: We can extract data for a specific point in time, or a time range (not covered here).\n\nWe're focusing on the years 2012--2025.\n`time-filter` needs the date time in a specific format.\nWe're building a helper function for this.\nAlso, we're building a helper function to create descriptive names for the resulting files.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyears <- 2012:2025\n\n# time format for osmium\nget_timestamp <- function(year) {\n  paste0(year, \"-01-01T00:00:00Z\")\n}\n\n# build file name based on year\nget_filename <- function(year) {\n  file.path(data_root, paste0(\"togo-\", year, \".osm.pbf\"))\n}\n```\n:::\n\n\n\nNext, we'll map over these years!\nWe're \n\n-   using `time-filter` (line 7)\n-   to access the cropped history file (line 8)\n-   for the given date time (line 9)\n-   and writing the corresponding file (lines 10--11)\n-   and getting the error messages in the `R` console (line 12).\n\nNow we've got our data, cropped for the area of interest, sliced into years.\n\n::: {.callout-note}\nThe way we used `time-filter`, it gives us the OSM file in its state on 1 January in each year.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"true\"}\n# Use walk2 to iterate over years and filter history file by date\nwalk(years, ~{\n  print(paste(\"extracting data for\", .x))\n  system2(\n    osmium,\n    args = c(\n      \"time-filter\",\n      file.path(data_root, \"history-250623-togo.osm.pbf\"),\n      get_timestamp(.x),                # date\n      \"-o\", get_filename(.x),           # output file name\n      \"--overwrite\" # output file overwrites existing file\n    ),\n    stderr = TRUE\n  )\n})\n```\n:::\n\n\n\n## Filtering the POIs with `duckDB`\n\nLet's find our POIs!\nFor this, we're using `duckDB`, a light-weight data base.\nAgain, we can call it from within `R`.\nIt ships with the `duckdb` package.\n`duckDB` comes with extensions, including a spatial one.\nWith this, we can handle spatial data and spatial formats, such as the `.osm.pbf` format.\n\n::: {.callout-note}\n`duckDB` cannot handly OSM history files -- it just drops the time information.\nThis is why we need to take a longer route: chopping up the history file first, then putting it back together with the year information.\n:::\n\nTo set it up, we first connect to the database.\nWe'll need to make sure we have the spatial extension installed and enabled.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# setup duckdb instance\ncon <- dbConnect(duckdb())\ndbExecute(con, \"INSTALL spatial;\")\ndbExecute(con, \"LOAD spatial;\")\n```\n:::\n\n\n\nTo make subsequent queries easier, we create a so-called common table expression [(`CTE`)](https://duckdb.org/docs/stable/sql/query_syntax/with.html).\nYou can imagine it like a `data.frame` in `R`.\nWe add the information where the file comes from (here: the year) in one column.\nThe process is a bit like applying `bind_rows` on a list of `data.frame`s.\n\nThis is implemented with some SQL magic.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqueries <- map_chr(years, ~{\n  glue(\"SELECT *, '{.x}' AS year FROM '{get_filename(.x)}'\")\n})\ncte <- paste(queries, collapse = \"\\nUNION ALL\\n\")\n```\n:::\n\n\n\nNow, finally, we can query our historic data for our POIs!\nFor that, we're selecting a couple of columns: \n\n-   id\n-   tag (for POI)\n-   lat, lon (geometry)\n-   year\n\nand then filtering for\n\n-   point geometries (*node* in OSM speech)\n-   restaurants (*amenity*: *restaurant* in OSM speech).\n\nLastly, we parse it to a `terra::vect` object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use CTE and get all restaurants with the respective year\nres <- dbGetQuery(\n  con,\n  glue(\n    \"WITH all_years AS ({cte})\n    SELECT \n      id,\n      tags,\n      lat,\n      lon,\n      year,\n    FROM all_years\n    WHERE\n      kind = 'node'\n      AND tags.amenity = 'restaurant';\n  \")\n) |> vect(geom = c(\"lon\", \"lat\"), crs = \"EPSG:4326\")\n```\n:::\n\n\n\n# Next steps\n\nThis approach can be optimized in many ways, e.g. by using the `osmium` filter tags somewhere in the pipeline to reduce the data we're working with.\n\nNow, we've got a `terra` object in `R`.\nThat means we're ready to wrangle and plot!\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}